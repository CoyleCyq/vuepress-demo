# 16 闭包和继承
- [闭包](#闭包)
    - [闭包的好处](#闭包的好处)
- [原型链](#原型链)
    - [原型模式的访问机制](#原型模式的访问机制)
        - [重置原型对象](#重置原型对象)
        - [内置原型对象](#内置原型对象)
    - [对象属性的遍历与判断](#对象属性的遍历与判断)
- [继承](#继承)
    - [原型链继承](#原型链继承)
    - [借用构造函数](#借用构造函数)
    - [组合继承](#组合继承)
    - [原型式继承](#原型式继承)
    - [寄生组合继承法](#寄生组合继承法)
- [ES6Class](#ES6Class)
    - [继承](#继承)
    - [静态方法](#静态方法)

<src-BackToTop></src-BackToTop>
<src-MetaChange></src-MetaChange>

## 闭包
闭包是这样一种机制: 函数嵌套函数, 内部函数可以引用外部函数的参数和变量,参数和变量不会被垃圾回收机制所收回. 

这里涉及到几个概念: 

1. 函数嵌套函数
2. 作用域(全局变量和局部变量)
变量的访问规则
3. 垃圾回收机制(garbage collection)
js内部不断扫描内存,并清理无引用对象(自动完成);

```js
function aa(){
    var num=100;
    console.log('aa中访问num：',num);
    function bb(){
      console.log("bb中访问num：",num);
    }
    return bb;
}
aa();
//bb(); //无法直接访问函数内部的函数
```
### 闭包的好处
1. 可以让一个变量长期驻扎在内存当中不被释放
2. 避免全局变量的污染, 和全局变量不同,  闭包中的变量无法被外部使用
3. 私有成员的存在, 无法被外部调用, 只可以自己内部使用

> 结论：
 
- 闭包是指有权访问另一函数作用域中的变量的函数
- 闭包，可以访问函数内部的局部变量，并让其长期驻留内存
- 由于闭包会携带包含它的作用域(运行环境)，因此会比其他函数占用更多内存，过度使用闭包可能会造成性能问题。

[案例]
- 点击按钮打印当前索引值
- tab标签切换

## 原型链
实例与Object原型对象之间的链条称为原型链

### 原型模式的访问机制
1. 读取实例对象的属性时，先从实例对象本身开始搜索。如果在实例中找到了这个属性，则返回该属性的值；
2. 如果没有找到，则继续搜索实例的原型对象，如果在原型对象中找到了这个属性，则返回该属性的值
3. 如果还是没找到，则向原型对象的原型对象查找，依此类推，直到Object的原型对象（最顶层对象）；
4. 如果再Object的原型对象中还搜索不到，则抛出错误；

### 重置原型对象
重置原型对象，可以一次性给原型对象添加多个方法
```js
function Popover(){}
Popover.prototype = {
    show:function(){},
    hide:function(){}
}
```
- 注意覆盖问题
- 注意识别问题

### 内置原型对象
使用内置原型可以给已有构造函数添加方法
 - 数组/字符串/数字等方法调用原理
 - 扩展内置方法

### 对象属性的遍历与判断
- `for…in`：遍历对象中的所有属性, 无论该属性存在于实例中还是原型中
- in：只要通过对象能够访问到属性就返回true, 无论该属性存在于实例中还是原型中

```js
if(name in s1){

}
```
- `实例.hasOwnProperty(属性)`：检测一个属性是存在于实例中(true)，还是存在于原型中(false)
- 检测一个属性是否存在于原型中：`!obj.hasOwnProperty(name) && (name in obj)`

## 继承
继承是面向对象中一个非常重要的特征。指的是：子类继承父类的属性和方法。

> 我们可以通过继承的方式, 在父类的属性和方法基础上, 让子类也拥有这些属性和方法, 并可以扩展。

- 继承的特点: 
1. 子类拥有父类所有的属性和方法（代码复用）；
2. 子类可以扩展自己的属性和方法（更灵活）；
3. 子类可以重写父类的方法

### 原型链继承
`prototype` 原型链属性(方法)的查找过程：实例–>原型对象–>原型对象… –> Object.prototype
> PS:原型链继承法一般用于继承方法

### 借用构造函数
- call：使用父类函数的call（子类对象,参数1，参数2，参数3......） 最常见

    格式：构造函数.call(this,参数1,参数2,参数3......)

- apply：使用父类函数的apply（子类对象，[参数1，参数2，参数3]）

    格式：父类构造函数.apply(子类当前对象,[参数1,参数2,参数3......]) //第二个参数为数组

- call与apply的唯一区别：传参方式不同
- 借用构造函数法只能继承构造函数里的属性/方法，不能继承原型对象里的方法
- 借用构造函数法一般用于继承属性

### 组合继承
- 继承属性：借用构造函数
- 继承方法：原型链继承

> 组合继承是最常用的继承模式。

缺点：

 - 多次执行父类构造函数
 - 在原型对象中生成多余的属性

### 原型式继承
原理：先创建了一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例
```js
function object(o){
    function F(){}
    F.prototype = o;
    return new F();
}
```
- Object.create()：ES5版本的原型式继承

### 寄生组合继承法
- 继承属性：借用构造函数
- 继承方法：原型式继承

## ES6Class
ES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类
```js
//定义类
class Person {
    constructor(name,age) {
        this.name = name;
        this.age = age;
    }
    getInfo() {
        return `我叫${this.name},今年${this.age}岁`;;
    }
}
```
写在类里面的方法实际是给`Person.prototype`添加方法
`constructor`方法是类的默认方法，通过`new`命令生成对象实例时，自动调用该方法。如果没有`constructor`方法，则得使用默认的`constractor`方法


### 继承
```js
class Person {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
}

class Man extends Person {
    constructor(name, age, gender) {
        //this.gender = gender; // 报错
        super(name, age);
        this.gender = gender; // 正确
    }
}      
```
- 子类继承了父类，在子类构造函数中必须调用`super`方法。
- 子类的`constructor`方法没有调用super之前，不能使用this关键字，否则报错，而放在super方法之后就是正确的。

### 静态方法
如果在一个方法前，加上`static`关键字，这就称为“静态方法”
```js
class Person {
    constructor(){
        this.name = 'laoxie',
        this.age = 18;
    }
    static getInfo(){
        return this.name
    }
    say(){
        console.log(`Hello everyone, my name is ${this.name}, I'm ${this.age} years old`)
    }
}
class Man extends Person {}
```
- 静态方法方法不会被实例继承，而是直接通过类来调用`Person.getInfo()`
- 父类的静态方法，可以被子类继承`Man.getInfo()`

